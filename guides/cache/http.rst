.. index::
   single: Кэш

HTTP Кэш
========

Лучшим способом улучшить производительность приложения будет, вероятно, 
кэшировать его вывод и обойти его полностью. Конечно же, это невозможно для 
сильно динамичных web сайтов, или все-таки можно? Этот раздел покажет вам, 
как работает система кэширования Symfony2 и почему мы думаем что это 
наилучший возможный подход.

Система кэширования Symfony2 полагается на простоту и мощь HTTP кэша, как 
это определено в спецификации HTTP. В основном, если вам уже знакомы модели 
кэширования HTTP валидации и устаревания, вы готовы к использованию 
большей части системы кэширования Symfony2.

.. index::
   single: Кэш; Типы
   single: Кэш; Прокси
   single: Кэш; Обратный Прокси
   single: Кэш; Шлюз

Разновидности Кэша
------------------

Заголовки HTTP кэша обрабатываются и интерпретируются тремя различными видами 
кэша:

* *Кэширование браузером*: Каждый браузер включает в себя собственный локальный кэш, 
  который наиболее полезен, когда вы нажимаете кнопку "back" или когда изображения 
  используются на web сайте неоднократно;

* *Proxy кэширование*: Прокси это *распределенный* кэш, так как много людей могут 
  использовать один и тот же кэш. Он всегда устанавливается большими корпорациями 
  и ISP для уменьшения латентности и сетевого трафика.

* *Gateway кэширование*: Как и прокси, тоже является распределенным кэшем, но на 
  серверной стороне. Установленный сетевыми администраторами, он делает web сайты 
  более масштабируемыми, надежными и более продуктивными (CDN-ы такие как Akamaï 
  являются gateway кэшами).

.. note::

    Gateway кэш иногда упоминается как обратный прокси кэш,
    кэш-заместитель, или даже HTTP акселератор.

Протокол HTTP 1.1 по умолчанию позволяет кэшировать все, за исключением  
явно указанного в заголовке ``Cache-Control``. На практике, большинство кэшей 
ничего не делают если в запросе установлены cookies, заголовок авторизации, или 
передача ведется по non-safe методу, и когда у ответа есть статус кода редиректа.

Symfony2 автоматически устанавливает рациональный и умеренный заголовок 
``Cache-Control`` когда он не указан разработчиком, следуя таким правилам:

* Если не указан заголовок кэша (``Cache-Control``, ``ETag``,
  ``Last-Modified``, и ``Expires``), ``Cache-Control`` устанавливается как 
  ``no-cache``;

* Если ``Cache-Control`` пустой, его значение устанавливается в ``private, 
  max-age=0, must-revalidate``;

* Но когда установлена хотя бы одна директива ``Cache-Control``, и явно не 
  добавлены директивы 'public' или ``private``, Symfony2 добавляет директиву 
  ``private`` автоматически (кроме случая, когда установлено ``s-maxage``).

.. tip::

    Большинство gateway кэшей могут удалять cookies перед перенаправлением 
    запроса к серверному приложению, и добавлять их обратно при отправке 
    ответа браузеру (это полезно для cookies, которые не изменяют 
    представление ресурса, такие как отслеживающие cookies).

Манипуляции с Заголовками Ответа
-----------------------------

Перед тем как мы начнем наш тур по различным HTTP заголовкам, которые вы 
можете использовать для включения кэширования в вашем приложении, первым 
делом вам нужно знать как изменять их в Symfony2 приложении.

Класс :class:`Symfony\\Component\\HttpFoundation\\Response` предоставляет красивый 
и простой API для упрощения манипуляций с HTTP заголовками::

    // передавайте массив заголовков третьим аргументом в конструктор Response
    $response = new Response($content, $status, $headers);

    // устанавливайте значение заголовка
    $response->headers->set('Content-Type', 'text/plain');

    // добавляйте значения заголовка к существующим значениям
    $response->headers->set('Vary', 'Accept', false);

    // устанавливайте заголовок с многими значениями
    $response->headers->set('Vary', array('Accept', 'Accept-Encoding'));

    // удаляйте заголовок
    $response->headers->delete('Content-Type');

Кроме этих встроенных путей установки заголовков, класс Response также предоставляет 
много специализированных методов, упрощающих манипуляции с заголовками HTTP кэша.
Далее вы узнаете о них больше.

.. tip::

    Имена HTTP заголовков регистро-независимы. Так как Symfony2 внутренне 
    конвертирует их в нормализированную форму, регистр ввода значения не имеет
    (``Content-Type`` рассматривается идентично с ``content-type``). Вы также 
    можете использовать нижние подчеркивания (``_``) вместо дефисов (``-``), если захотите.

Если вы используете укороченный метод класса Controller ``render`` для формирования шаблона и 
создания объекта Response, вы также можете легко манипулировать заголовками Response::

    // Сперва создайте объект Response и установите заголовки...
    $response = new Response();
    $response->headers->set('Content-Type', 'text/plain');

    // ...и потом установите их как третий аргумент в метод render
    return $this->render($name, $vars, $response);

    // Или, вызовите render сначала...
    $response = $this->render($name, $vars);

    // ...и манипулируйте заголовками Response потом
    $response->headers->set('Content-Type', 'text/plain');

    return $response;

.. index::
   single: Кэш; HTTP

Понимание HTTP Кэша
-------------------

HTTP спецификация (aka `RFC 2616`_) определяет две модели кэширования:

* *Истечение*: Вы указываете как долго ответ считается "свежим" путем установки
  ``Cache-Control`` и/или ``Expires`` заголовков. При кэшировании помните, 
  что истечение не будет делать одинаковый запрос пока кэшируемая версия 
  не достигнет своего времени истечения срока и станет "старой".

* *Валидация*: Когда некоторые страницы действительно динамичны (в смысле, что их 
  содержимое часто изменяется), модель валидации использует уникальный идентификатор
  (заголовок ``Etag``) и/или метку времени (заголовок ``Last-Modified``) для проверки, 
  изменилась ли страница с последнего раза.

Целью обоих моделей является никогда не генерировать один и тот же Response дважды.

.. tip::

    Принимаются усилия (`HTTP Bis`_) переписать RFC 2616. Он не описывает
    новую версию HTTP, но преимущественно освещает первоначальную спецификацию HTTP.
    Организация также намного лучше, так как спецификация разделена на несколько 
    частей; все что касается HTTP кэширования может быть найдено в двух разделенных
    частях (`P4 - Conditional Requests`_ and `P6 - Caching: Browser and intermediary caches`_).

.. tip::

    Заголовки HTTP кэша работают только с "безопасными" (safe) HTTP методами (такими как 
    GET и HEAD). Быть безопасным означает, что вы никогда не должны изменять состояние 
    приложения на сервере когда отрабатываются такие запросы (но вы, конечно же, можете 
    логировать информацию, кэшировать данные, ...)

.. index::
   single: Кэш; HTTP Истечение

Истечение
~~~~~~~~~

По возможности, нужно использовать модель кэширования с истечением, если ваше 
приложение будет вызвано при первом запросе и оно не будет вызываться снова пока 
не устареет (это экономит CPU сервера и улучшает масштабируемость).

.. index::
   single: Кэш; заголовок Истечения
   single: HTTP заголовки; Истечение

Истечение с заголовком ``Expires``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В соответствии с RFC 2616, "the ``Expires`` header field gives the date/time after
which the response is considered stale." Заголовок ``Expires`` может быть установлен 
при помощи ``setExpires()`` метод класса Response. Он принимает экземпляр ``DateTime`` 
в качестве аргумента::

    $date = new DateTime();
    $date->modify('+600 seconds');

    $response->setExpires($date);

.. note::

    Метод ``setExpires()`` автоматически конвертирует дату в формат GMT, 
    чего требует спецификация (дата должна быть в формате RFC1123).

Заголовок ``Expires`` обладает двумя недостатками. Во-первых, часы Web сервера
и кэша (aka браузера) должны быть синхронизированы. Далее, спецификация состояний
указывает что "HTTP/1.1 servers should not send ``Expires`` dates
more than one year in the future." (Серверы с поддержкой HTTP/1.1 не должны отсылать
``Expires`` даты ранее чем через год.)

.. index::
   single: Кэш; Cache-Control заголовок
   single: HTTP заголовки; Cache-Control

Истечение с заголовком ``Cache-Control``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Так как у заголовка ``Expires`` есть ограничения, чаще всего, вам следует
использовать вместо него заголовок ``Cache-Control``. Так как ``Cache-Control``
это заголовок общего назначения, используемый для установки различных директив,
Symfony2 предоставляет методы, которые абстрагируют манипуляции ими. Для истечения,
есть две директивы, ``max-age`` и ``s-maxage``. Первая используется всеми видами 
кэшей, тогда как вторая берется во внимание только shared кэшами::

    // Устанавливает количество секунд по истечению которых
    // ответ уже не будет считаться свежим
    $response->setMaxAge(600);

    // Тоже что и сверху, но только для shared кэшей
    $response->setSharedMaxAge(600);

.. index::
   single: Кэш; Валидация

Валидация
~~~~~~~~~

Когда ресурс должен быть обновлен как только были изменены данные, модель
истечения терпит крах. Модель валидации решает эту задачу. В этой модели,
вы преимущественно экономите каналы передачи данных, так как представление не
отсылается дважды одному и тому же клиенту (вместо этого отсылается ответ 304).
Но если вы внимательно проектируете дизайн вашего приложения, у вас должна быть
возможность получить минимальный объем данных, необходимый для отправки ответа
304, и также сэкономить CPU; и если необходимо, выполнить более трудоемкие
задачи (смотрите ниже практический пример).

.. index::
   single: Кэш; Etag заголовок
   single: HTTP заголовки; Etag

Валидация с использованием заголовка ``ETag``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В соответствии с RFC, "Поле ответа-заголовка ``ETag`` предоставляет текущее
значение entity-tag для одного представления рассматриваемого ресурса.
Entity-tag предполагается использовать в качестве локального для ресурса
идентификатора для дифференциации между представлениями одного и того же
ресурса, изменяющегося во времени или через согласование содержания.".
"Entity-tag ДОЛЖЕН быть уникальным во всех версиях всех представлений,
ассоциированных с конкретным ресурсом."

Возможным значением для "entity-tag" может быть, например, хэш содержимого
ответа::

    $response->setETag(md5($response->getContent()));

Этот алгоритм достаточно прост и очень универсален, но вам нужно создать
Response полностью, перед тем как вы сможете рассчитать ETag, что не совсем
оптимально. Эта стратегия часто используется как алгоритм по умолчанию во
многих фреймворках, но вам следует использовать какой-нибудь алгоритм,
который лучше учитывает путь создания ресурсов (смотрите секцию ниже про
оптимизацию валидации).

.. tip::

    Symfony2 также поддерживает слабые ETags путем передачи ``true`` в качестве
    второго аргумента в метод
    :method:`Symfony\\Component\\HttpFoundation\\Response::setETag`.

.. index::
   single: Кэш; Last-Modified заголовок
   single: HTTP заголовки; Last-Modified

Валидация с использованием заголовка ``Last-Modified``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В соответствии с RFC, "Поле заголовка ``Last-Modified`` отображает
дату и время, при которой, по мнению главного сервера, отображение было
последний раз изменено."

Например, в качестве даты последнего изменения для всех объектов, требующих 
расчета времени отображения, значение заголовка ``Last-Modified``::

    $articleDate = new \DateTime($article->getUpdatedAt());
    $authorDate = new \DateTime($author->getUpdatedAt());

    $date = $authorDate > $articleDate ? $authorDate : $articleDate;

    $response->setLastModified($date);

.. index::
   single: Cache; Conditional Get
   single: HTTP; 304

Оптимизация вашего Кода при помощи Валидации
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Главной целью любой стратегии кэширования является облегчение загрузки
приложения; следуя другим путем, минимум что можно сделать в вашем
приложении - вернуть ответ 304, что еще лучще. Метод Symfony2
``Response::isNotModified()`` делает именно это через использование
простого и производительного паттерна::

    // Получаем минимум информации для вычисления
    // ETag или значение Last-Modified
    // (базируясь на Request, данных полученных из
    // базы данных или хранилища ключ-значение)
    $article = Article::get(...);

    // создадим объект Response с заголовком ETag и/или a Last-Modified
    $response = new Response();
    $response->setETag($article->computeETag());
    $response->setLastModified($article->getPublishedAt());

    // Проверяем что Response не изменился для заданного Request
    if ($response->isNotModified($request)) {
        // сразу же отсылаем 304 Response
        $response->send();
    } else {
        // делаем здесь что-нибудь трудоемкое
        // такое как работа с БД
        // и рендеринг шаблона
    }

Когда Response не был изменен, ``isNotModified()`` автоматически
устанавливает статус кода ответа ``304``, удалите содержимое, и удалите
некоторые заголовки которые не должны присутствовать в ответах ``304``
(смотрите :method:`Symfony\\Component\\HttpFoundation\\Response::setNotModified`).

.. index::
   single: Кэш; Vary
   single: HTTP заголовки; Vary

Заголовок Vary в объекте Response
~~~~~~~~~~~~~~~~~~~~~

Иногда, представление ресурса зависит не только от его URI, но также и от
значений некоторых заголовков. Например, если вы сжимаете страницы, когда это
поддерживает клиент, каждый выдаваемый URI имеет два представления: одно когда
клиент поддерживает компрессию, и еще одно когда нет. Для таких случаев, вы
должны использовать заголовок ``Vary``, чтобы помочь кэшу определить, когда
хранимый ответ может быть использован в соответствии в полученным запросом::

    $response->setVary('Accept-Encoding');

    $response->setVary(array('Accept-Encoding', 'Accept'));

Метод ``setVary()`` получает имя заголовка или массив имен заголовков от
которых изменяется ответ.

Истечение и Валидация
~~~~~~~~~~~~~~~~~~~~~

Конечно вы можете использовать одновременно и валидацию и истечение в
одинаковых Response. Так как истечение выигрывает у валидации, вы можете
легко взять лучшее из обоих миров. Это дает вам множество путей настройки
и корректировки вашей стратегии кэширования.

.. index::
    pair: Кэш; Конфигурация

Больше Методов Response
~~~~~~~~~~~~~~~~~~~~~~~

Класс Response предоставляет еще множество методов связанных с кэшем. Вот самые 
полезные из них::

    // Пометим Response как приватный
    $response->setPrivate();

    // Пометим Response как публичный
    $response->setPublic();

    // Пометим Response как устаревший
    $response->expire();

Последнее но совсем не последнее по значимости, большинство HTTP заголовков
связанных с кэшем, могут быть установлены вызовом одного
метода ``setCache()``::

    // Установим настройки кэша в один вызов
    $response->setCache(array(
        'etag'          => $etag,
        'last_modified' => $date,
        'max_age'       => 10,
        'public'        => true,
    ));

Конфигурирование Кэша
---------------------

Как вы уже догадались, наилучшей конфигурацией для ускорения вашего приложения
будет добавление gateway cache на входе вашего приложения. И так как Symfony2
использует только стандартные HTTP заголовки для управления его кэшем, здесь
нет необходимости в внутреннем слое кэша. Вместо этого, вы можете использовать
любой обратный прокси какой захотите, такой как Apache mod_cache, Squid, или
Varnish. Если вы не хотите устанавливать дополнительное программное обеспечение,
вы можете использовать обратный прокси встроенный в Symfony2, который написан на
PHP и делает ту же работу что и любой другой обратный прокси.

Публичный Response против Приватного Response
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Как показано в начале этой статьи, Symfony2 очень консервативна
и делает все Response приватными по умолчанию (точные правила описаны тут).

Если вы хотите использовать shared кэш, вы должны помнить явно добавлять
``public`` директиву к ``Cache-Control``::

    // Response приватный по умолчанию
    $response->setEtag($etag);
    $response->setLastModified($date);
    $response->setMaxAge(10);

    // Меняем Response что бы сделать его публичным
    $response->setPublic();

    // Устанавливаем настройки кэша в один вызов
    $response->setCache(array(
        'etag'          => $etag,
        'last_modified' => $date,
        'max_age'       => 10,
        'public'        => true,
    ));

Обратный прокси Symfony2
~~~~~~~~~~~~~~~~~~~~~~

Symfony2 поставляется со встроенным обратным прокси написаным на PHP. Вкличите его и он
начнет кэшировать ресурсы вашего приложениея правильно. Его установка проста настолько
насколько это возможно. Каждое Symfony2 приложение идет с пред-настройками кэширующего
Ядра (``AppCache``) которое обрамляет стандартное ядро (``AppKernel``).
Измените код фронт-контроллера, что бы включить кэширование::

    // web/app.php

    require_once __DIR__.'/../app/AppCache.php';

    use Symfony\Component\HttpFoundation\Request;

    // оберните стандартное Ядро AppKernel в кэширующее Ядро AppCache
    $kernel = new AppCache(new AppKernel('prod', false));
    $kernel->handle(new Request())->send();

.. tip::

    В кэширующеем ядре есть специальный ``getLog()`` метод который возвращает строку,
    представление того что произошло на уровне кэша. В окружении разработки (dev environment)
    используйте его для отладки и проверки стратегии кэша:

        error_log($kernel->getLog());

Объект ``AppCache`` имеет разумную конфигурацию по умолчанию, но она может быть
тонко настроена с помощью установки параметров. Вы можете перегрузить ``getOptions()`` method::

    // app/AppCache.php
    class AppCache extends Cache
    {
        protected function getOptions()
        {
            return array(
                'debug'                  => false,
                'default_ttl'            => 0,
                'private_headers'        => array('Authorization', 'Cookie'),
                'allow_reload'           => false,
                'allow_revalidate'       => false,
                'stale_while_revalidate' => 2,
                'stale_if_error'         => 60,
            );
        }
    }

Ниже перечень главных настроек:

* ``default_ttl``: Число секунд в течении которых вхождение в кэш должно
  считаться свежим, когда информация о "свежести" явно не приведена в response.
  Явное указание ``Cache-Control`` или ``Expires`` заголовков перегружает это
  значение (по умолчанию: ``0``);

* ``private_headers``: Набор заголовков запроса который вызывает "private" поведение ``Cache-Control``,
  в ответах которые не имеют явного состояния ``public`` или ``private``,
  с помощью директивы ``Cache-Control``.
  (по умолчинию: ``Authorization`` и ``Cookie``);

* ``allow_reload``: Указывает может ли клиент заставить перезагрузить кэш
  путем включения ``Cache-Control`` директивы "no-cache" в запрос. Установите в
  ``true`` для соответствия RFC 2616 (по умолчинию: ``false``);

* ``allow_revalidate``: Указывает может ли клиент заставить перезагрузить кэш
  путем включения ``Cache-Control`` директивы "max-age=0" в запрос.
  Установите в ``true`` для соответствия RFC 2616 (по умолчинию: ``false``);

* ``stale_while_revalidate``:  Определяет стандартное количество секунд (с точностью до
  секунды, так как точность времени жизни Response измеряется в секундах) в течении
  которых кэш может немедленно возвращать устаревший ответ, пока он обновляется в фоне
  (по умолчинию: ``2``); эта настройка перекрывается
  ``stale-while-revalidate`` HTTP расширением ``Cache-Control`` (смотри RFC 5861);

* ``stale_if_error``: Определяет стандартное количество секунд (с точностью до
  секунды) в течении которых кэш может отдавать устаревший ответ если возникла
  ошибка (по умолчинию: ``60``). Эта настройка перекрывается
  ``stale-if-error`` HTTP расширением ``Cache-Control`` (смотри RFC 5861).

Если опция ``debug`` установлена как ``true``, Symfony2 автоматически добавляет
заголовок ``X-Symfony-Cache`` к Response, который содержит полезную информацию
касательно попаданий и промахов в кэш.

Обратный прокси Symfony2 хорощий инструмент для разработки вашего сайта
в вашей локальной сети или когда вы разворачиваете ваш сайт на shared хостинг где
вы не можете установить ничего кроме PHP. Но написанный на PHP, он не может
быть быстрым как прокси написанный на C. Поэтому мы настоятельно рекомендуем
использовать Squid или Varnish на вашем боевом сервере если это возможно. Хорошие
новости то что, переключение с одного прокси сервера на другой является легким и
прозрачным, так как не требует модификации кода в вашем приложении; легко начать со
встроенным в Symfony2 обратным прокси и позже перейти на Varnish когда нагрузки возростут.

.. note::

    Производительность обратного прокси Symfony2 не зависит от сложности
    приложения; это потому что ядро приложения запускается только тогда, когда
    запрос должен быть передан в него.

Apache mod_cache
~~~~~~~~~~~~~~~~

Если вы используете Apache, он может выступать как простой gateway кэш, когда
расширение mod_cache включено.

Squid
~~~~~

Squid это "обычный" прокси сервер, который также может выступать в роли обратного прокси.
Если вы уже используете Squid в вашей архитектуре, вы вероятно будете использовать
его мощь для вашего Symfony2 приложения. Если нет, мы настоятельно рекомендуем
вам использовать Varnish, так как он имеет множество преимуществ перед Squid и протому что
он поддерживает функции необходимые для продвинутых стратегий кэширования Symfony2 (таких как
поддержка ESI).

Varnish
~~~~~~~

Varnish это наш предпочтительный выбор, из-за трех главных причин:

* Он был изначально разработан как обратный прокси, его настройка предельно прота;

* Его современная архитектура означает что, он невероятно быстр;

* Он поддерживает ESI, технология которая используется Symfony2 для того, что бы
  разные части страници имели свою собственную стратегию кэширования.
  Прочтите следующий раздел для подробной информации.

.. index::
  single: Cache; ESI
  single: ESI

Использование Edge Side Includes
------------------------

Gateway кэши хороший способ сделать ваш сайт лучше. Но они имеют одно ограничени:
они могут кэшировать страницы только полностью. Что ж, если вы не можете кэшировать
страницы полностью или если страница имеет "много" динамичестих частей, вам не повезло.
К щастью, Symfony2 предлагает решение на этот случай, основанное на технологии
называемой `ESI`_, or Edge Side Includes. Akamaï написал эту спецификацию почти
10 лет назад, она позволяет определить части страницы которые будут иметь стратегии
кэширования отличные от основной страницы.

ESI спецификация описывает тэги которые вы можете вставить в ваши страницы для
связи с gateway кэшем. Только один тэг реализован в Symfony2,
``include``, так как он один полезен вне контекста Akamaï:

.. code-block:: html

    <html>
        <body>
            Some content

            <!-- Вставте содержание другой страницы тут -->
            <esi:include src="http://..." />

            More content
        </body>
    </html>

Когда приходит request, gateway кэш берет страницу из своего кэша или
вызывает приложение. Если response содержит один или более ESI тэга,
proxy ведет себя как для основного request. Он берет содержимое вложенной страницы
из своего кэша или снова вызывает приложение. Потом он проводит слияние всего вложенного,
в основную страницу, содержимого и отправляет назад клиенту.

.. index::
    single: Helper; actions

Так как вложенное содержимое приходит с другой страницы (в данном случае
с другого контроллера), Symfony2 использует стандартный хелпер ``render`` для настройки ESI тэгов:

.. configuration-block::

    .. code-block:: php

        <?php echo $view['actions']->render('...:list', array(), array('standalone' => true)) ?>

    .. code-block:: jinja

        {% render '...:list' with [], ['standalone': true] %}

С установкой настройки ``standalone`` в значение ``true``, вы говорите Symfony2 что
это действие должно быть отабражено как ESI тэг. Вы можете быть удивлены, почему вам стоит
использовать helper, а не просто писать теги ESI самостоятельно.
Это потому что используя helper, вы делаете приложение работоспособным даже если
gateway кэш не установлен. Давайте посмотрим как это работает.

Когда настройка ``standalone`` установлена как ``false`` (по умолчанию), Symfony2
объединяет содержимое вложенных страниц в основную страницу, перед тем как послать response
клиенту. Но Когда настройка ``standalone`` установлена как ``true`` и если Symfony2
обнаруживает что она связывается с gateway кэшем, который поддерживает ESI, она генерирует
ESI тэг ``include``. Но если gateway кэш отсутствует или он не поддерживает ESI,
Symfony2 будет объединять содержимое вложенных страниц в основную страницу, так как если бы
``standalone`` был бы``false``.

.. note::

    Symfony2 обнаруживает поддерживает ли gateway кэш ESI с помощью другой Akamaï
    спецификации, которая поддерживается "из коробки" в обратном прокси Symfony2
    (рабочая коняигурация для Varnish также приведена ниже).

Для того что бы ESI тэг ``include`` работал коректно, вы должны определить ``_internal``
роутинг:

.. configuration-block::

    .. code-block:: yaml

        # app/config/routing.yml
        _internal:
            resource: FrameworkBundle/Resources/config/routing/internal.xml
            prefix:   /_internal

    .. code-block:: xml

        <!-- app/config/routing.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>

        <routes xmlns="http://www.symfony-project.org/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.symfony-project.org/schema/routing http://www.symfony-project.org/schema/routing/routing-1.0.xsd">

            <import resource="FrameworkBundle/Resources/config/routing/internal.xml" prefix="/_internal" />
        </routes>

    .. code-block:: php

        // app/config/routing.php
        use Symfony\Component\Routing\RouteCollection;
        use Symfony\Component\Routing\Route;

        $collection->addCollection($loader->import('FrameworkBundle/Resources/config/routing/internal.xml', '/_internal'));

        return $collection;

.. tip::

    Возможно вы захотите защитить этот роутинг, либо выбрав нелегко угадываемый префикс,
    или защитив его используя возможности Symfony2 firewall
    (разрешая доступ к диапазону IP вашего обратного прокси).

Одно большое приемущество этой стратегии кэширования то, что вы можете сделать ваше
приложение настолько динамичным насколько это необходимо и в тоже время, "дергать" приложение
как можно меньше.

.. note::

    Однажды начав использовать ESI, не забывайте всегда использовать директиву
    ``s-maxage`` вместо ``max-age``. Так как браузер всегда получает собраный ресурс,
    он никогда не будет беспокоится о суб-компонентах, браузер будет придерживаться
    директивы ``max-age`` и кэша всей страницы. А вы не хотите этого, не так ли.

.. tip::

    Хелпер ``render`` поддерживает две других полезных опции, ``alt`` и
    ``ignore_errors``. Они автоматичести конвертируются в ``alt`` и
    ``onerror`` атрибуты, когда ESI тэг ``include`` генерируется.

.. index::
    single: Cache; Varnish

Конфигурация Varnish
~~~~~~~~~~~~~~~~~~~~~

Как было показано ранее, Symfony2 достаточно умна для определения работает она с
обрантым-прокси который поддерживает ESI или нет. Это работает прямо из коробки,
когда вы используете обратный прокси Symfony2, но вам неоходима особая настройка для
того, что бы работать с Varnish. К счастью, Symfony2 опирается на еще один стандарт
описанный Akamaï (`Edge Architecture`_), подсказки по настройке в этой главе могут
быть полезны даже если вы не используете Symfony2.

.. note::

    Varnish поддерживает только атрибут ``src`` для ESI тэгов (атрибуты ``onerror`` и
    ``alt`` будут проигнорированы).

Первое, настройте Varnish так что бы он сообщал то, что он поддерживает ESI, путем добавления
заголовка ``Surrogate-Capability`` к запросам направляемым к
приложению:

.. code-block:: text

    sub vcl_recv {
        set req.http.Surrogate-Capability = "abc=ESI/1.0";
    }

Потом, оптимизируйте Varnish так, что бы он обрабатывал содержимое Response только когда есть
хотя бы один ESI тэг, путем проверки заголовка ``Surrogate-Control``, который
Symfony2 добавляет автоматически:

.. code-block:: text

    sub vcl_fetch {
        if (beresp.http.Surrogate-Control ~ "ESI/1.0") {
            unset beresp.http.Surrogate-Control;
            esi;
        }
    }

.. caution::

    Не используйте сжатие всесте с ESI так как Varnish не сможет обработать
    содержимое ответа. Если вы хотите использовать компрессию, установите веб-сервер
    перед Varnish для этого.

.. index::
    single: Cache; Invalidation

Анулирование
------------

"Есть только две сложных вещи в Компьютерной Науке: анулирование кэша и
именование вещей." --Phil Karlton

Вам нет необходимости анулировать кэш потому что, это уже сделано в
модели HTTP кэширования. Если вы используете валидацию, вам никогда не нужно
использовать анулирование по определению; а если вы используете устаревания и
хотите анулировать ресурс, это значит что вы установили слишком далекую дату устаревания.

.. note::

    Это потому что нет такого механизма устаревания который вы могли бы использовать
    вместе с обратным прокси без изменения кода вашего приложения.

На самом деле, все обратные прокси предоставляют способы для очистки кэша, но вы
должны избегать этого насколько это возможно. Более стандартный способ очистить кэш,
это специальный URL, который нужно запросить со специальным HTTP методом ``PURGE``.

.. index::
    single: Cache; Invalidation with Varnish

Вот как вы можете настроить обратный кэш Symfony2 для поддержки
HTTP метода ``PURGE``::

    // app/AppCache.php
    class AppCache extends Cache
    {
        protected function invalidate(Request $request)
        {
            if ('PURGE' !== $request->getMethod()) {
                return parent::invalidate($request);
            }

            $response = new Response();
            if (!$this->store->purge($request->getUri())) {
                $response->setStatusCode(404, 'Not purged');
            } else {
                $response->setStatusCode(200, 'Purged');
            }

            return $response;
        }
    }

То же самое можно сделать с помощью Varnish:

.. code-block:: text

    sub vcl_hit {
        if (req.request == "PURGE") {
            set obj.ttl = 0s;
            error 200 "Purged";
        }
    }

    sub vcl_miss {
        if (req.request == "PURGE") {
            error 404 "Not purged";
        }
    }

.. caution::

    Вы должны защитить HTTP метод ``PURGE`` любым способом, во избежании
    очистки вашего кэша случайными людьми.

.. _`RFC 2616`: http://www.ietf.org/rfc/rfc2616.txt
.. _`HTTP Bis`: http://tools.ietf.org/wg/httpbis/
.. _`P4 - Conditional Requests`: http://tools.ietf.org/id/draft-ietf-httpbis-p4-conditional-12.txt
.. _`P6 - Caching: Browser and intermediary caches`: http://tools.ietf.org/id/draft-ietf-httpbis-p6-cache-12.txt
.. _`ESI`: http://www.w3.org/TR/esi-lang
.. _`Edge Architecture`: http://www.w3.org/TR/edge-arch
